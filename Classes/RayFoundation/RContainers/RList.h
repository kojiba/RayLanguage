/** * @file RList.h * @brief Realization of C dynamic double-linked list. *        In Ray additions. * * @author Kucheruavyu Ilya (kojiba@protonmail.com) * @date 1/23/2015 * @par Ukraine Kharkiv * *//* *  _         _ _ _ * | |       (_|_) | * | | _____  _ _| |__   __ _ * | |/ / _ \| | | '_ \ / _` | * |   < (_) | | | |_) | (_| | * |_|\_\___/| |_|_.__/ \__,_| *          _/ | *         |__/ */#ifndef __R_LIST_H__#define __R_LIST_H__#include "RArray.h"#ifdef RAY_LIST_THREAD_SAFE    #include "../RThread/RThread.h"#endifstruct RList;typedef struct RNode { ///< base struct for double linked node    struct RNode   *next;     ///< next RNode or nil    struct RNode   *previous; ///< previous RNode or nil           pointer  data;     ///< pointer to data} RNode;/** * @par RList main struct is: * *      tail                                                        head *        |                                                           | *      node1(data1) <-> node2(data2) <-> node3(data3) <-> ... <-> nodeLast(dataLast) *      \___________________________ object->count ________________________________/ * */class(RList) //--------------------------------------------------------------------------    RNode  *head; ///< pointer to last RNode or nil    RNode  *tail; ///< pointer to first RNode or nil    size_t  count; ///< nodes count readonly, signaling about successful addition, deletion of elements    DestructorDelegate destructorDelegate; ///< destructor of elements delegate    PrinterDelegate    printerDelegate;    ///< printer of elements delegate#ifdef RAY_LIST_THREAD_SAFE    RMutex mutex; ///< single thread lock (mutex), normal#endifendOf(RList) //--------------------------------------------------------------------------/** * Default constructor for RList instances. * Allocs memory only for struct, head and tail is nil by default. * * @return Created instance of RList or nil if error occurs. */constructor (RList));/** * Destructor for RList instances, free inner array, * perform destructorDelegate on inner stored data pointers. */destructor  (RList);/** * Default printer for RList instances. * perform printerDelegate on inner stored data pointers. */printer     (RList);#pragma mark Add/** * Adding method for add data to RList. * Locks mutex if threadsafe, * allocs worker struct, set data ptr to it, * links it with old head and set head pointer to it. * Increment count. * * @param    src    Data to add */method(void,                 addHead,       RList),    pointer src);/** * Adding method for add data to RList. * Locks mutex if threadsafe, * allocs worker struct, set data ptr to it, * links it with old tail and set tail pointer to it. * Increment count. * * @param    src    Data to add */method(void,                 addTail,       RList),    pointer src);#pragma mark Get/** * Main node gettings method. * Firstly checking from which side must run iterator (head, tail), * than run it. * * @param    index    Index to get data on * * @return   pointer to node at index or nil */constMethod(RNode *,         nodeAtIndex,   RList),    size_t index);/** * Main data gettings method. * Using RList.nodeAtIndex * * @param    index    Index to get data on * * @return   pointer to data at index or nil */constMethod(pointer,         objectAtIndex, RList),    size_t index);/** * Method to get sub list from RList. * Firstly checking from which side move (head, tail). * Using RList.nodeAtIndex than, * RList.addHead or RList.addTail * * @param    range    Range to sublist get * * @return   pointer to sub list with new nodes created and data, delegates copied, or nil */method(RList *,              subList,       RList),    RRange range); // copy of sub-part, with set-upd delegates#pragma mark Enumerate/** * Default enumerator, see RArray.enumerate. */constMethod(RFindResult,     enumerate,     RList),    REnumerateDelegate *delegate, rbool isFromLeft);#pragma mark Delete/** * Method to deletes nodes with data in RList. * Perform object->destructorDelegate on deleting objects, than delete and unlink nodes. * * @param    range    Range to deletes objects */method(void,                 deleteObjects, RList),    RRange range);/** * Method to deletes single node with data in RList. * Perform object->destructorDelegate on node, than delete and unlink nodes. * * @param    range    Range to deletes objects */method(void,                 deleteObject,  RList),    size_t index);#pragma mark Casts/** * Method for creating RArray from RList. * Using RArray.makeRArrayOptions and RArray.addObjectUnsafe. * * @return Created RArray with copied data pointers and delegates or nil */constMethod(struct RArray *, toRArray,      RList));#endif /*__R_LIST_H__*/