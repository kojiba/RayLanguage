/** *  _____ * |  __ \ * | |__) | __ _  _   _ * |  _  / / _` || | | | * | | \ \| (_| || |_| | * |_|  \_\\__,_| \__, | *                 __/ | *                |___/ *  ______                        _         _    _ * |  ____|                      | |       | |  (_) * | |__  ___   _   _  _ __    __| |  __ _ | |_  _   ___   _ __ * |  __|/ _ \ | | | || '_ \  / _` | / _` || __|| | / _ \ | '_ \ * | |  | (_) || |_| || | | || (_| || (_| || |_ | || (_) || | | | * |_|   \___/  \__,_||_| |_| \__,_| \__,_| \__||_| \___/ |_| |_| * **/#include <RayFoundation.h>typedef struct ComplexStruct {    size_t id;    RCString *fullName;} ComplexStruct;void printComplexStruct(ComplexStruct *some) {    printf("%p | id: %02lu | fullname : \'%s\' \n", some, some->id, some->fullName->baseString);}void complexDeleter(ComplexStruct *some) {    deleter(some->fullName, RCString);    free(some);}int main(int argc, const char *argv[]) {    size_t iterator;    RArray *array = makeRArray(); // create array    // sets delegates for automatic print and cleanup    array->printerDelegate = (PrinterDelegate) printComplexStruct;    array->destructorDelegate = (DestructorDelegate) complexDeleter;    forAll(iterator, 100) {        // create struct and add to array        ComplexStruct *some = malloc(sizeof(ComplexStruct));        some->id = iterator + 1;        some->fullName = stringWithFormat("Object # %lu", iterator + 1); // more string processing API in RCString.h        $(array, m(addObject, RArray)), some);    }    // print    printerOfRArray(array);    // delete, automatically calls destructor delegate and free array prt    deleter(array, RArray);    // some syntaxic sugar see initFromArray, initFromArrayWithSizes, arrayFromArray    // create array of strings    RCString *uniqTok = RS("Unique token");    array = RA(RS("Token 1"), RS("Token 2"), uniqTok, nil); // must be NULL terminated    array->printerDelegate = (PrinterDelegate) p(RCString);    array->destructorDelegate = free;    printerOfRArray(array);    RCompareDelegate delegate;    delegate.etaloneObject = uniqTok;    delegate.virtualCompareMethod = (RCompareFlags (*)(pointer, pointer)) compareWithRCString;    RFindResult result = findObjectWithDelegateRArray(array, &delegate); // search    if(result.object != nil) { // object != nil -> found object, place also logged        printf("Found some object at place %lu!\n", result.index);    } else {        printf("Object not found!\n");    }    RArray *subarray = getSubarrayRArray(array, makeRRange(1, 2)); // delegates will be copied    printerOfRArray(subarray);    subarray->destructorDelegate = nil; // not want to delete strings    deleter(subarray, RArray);    deleter(array, RArray); // cleanup strings    return 0;}