{"name":"Raylanguage","tagline":"Additions to C functional. (Containers, strings operations, memory operations, sockets, threads, etc...)","body":"![RayFoundation](https://raw.githubusercontent.com/kojiba/RayLanguage/master/foundation.logo.png \"RayFoundation\")\r\n===========\r\n\r\nHAPPY MERRY CHRISTMAS AND A HAPPY NEW YEAR! =)  \r\n\r\n**If You have some ideas, or found bugs - create issues here on github or email me.**\r\n\r\nfirstly:\r\nRay additions to C language defines some C-based syntax, \r\nthat makes object-oriented life easier for C developers.\r\nAll based on defines and can use diff.  \r\n  \r\nContainers:  \r\n1.  Array, List - NSArray, std::vector, list analog  \r\n2.  Dictionary - NSDictionary, std::map analog  \r\n3.  Buffer - store full copy of objects  \r\n4.  Data - base sized data class for strings, and bytes  \r\n  \r\nStrings and raw bytes:  \r\n1. Wide range of string processing operations (RString)  \r\n2. Replacings  \r\n3. Find of substring or symbol  \r\n4. Delete characters/substrings  \r\n5. Delete of duplications characters/substring  \r\n6. Compares  \r\n7. Read from file/ apend to file  \r\n8. Tokenization into container Array  \r\n9. Base64 encoding/decoding  \r\n10. etc...  \r\n  \r\nSystem dependent Utils (WINAPI + POSIX):  \r\n1. RThread and RThreadPool  \r\n2. RSocket (WINAPI + Berkley)  \r\n3. RTCPHandler - multi-threaded tcp server engine  \r\n  \r\nMemory operations:  \r\n1. Easy sandboxing and testing with logging  \r\n2. Memory management with RAutoPool (Checking leaks, manage allocations)  \r\n3. Work with byte buffers and memory chunks  \r\n\r\nSome test projects based on RayFoundation:  \r\n1. Simple VM with Brainfuck compiler and execution visualization in Curses  \r\n2. Simple TCP multi-threaded text-chat with 'nc' util client \r\n\r\nWork with RArray:  \r\n\r\n```C\r\n#include <RayFoundation.h>\r\n\r\ntypedef struct ComplexStruct {\r\n    size_t id;\r\n    RString *fullName;\r\n} ComplexStruct;\r\n\r\nvoid printComplexStruct(ComplexStruct *some) {\r\n    printf(\"%p | id: %02lu | fullname : \\'%s\\' \\n\", some, some->id, some->fullName->baseString);\r\n}\r\n\r\nvoid complexDeleter(ComplexStruct *some) {\r\n    deleter(some->fullName, RString);\r\n    free(some);\r\n}\r\n\r\nint main(int argc, const char *argv[]) {\r\n    size_t iterator;\r\n\r\n    RArray *array = makeRArray(); // create array\r\n    // sets delegates for automatic print and cleanup\r\n    array->printerDelegate = (PrinterDelegate) printComplexStruct;\r\n    array->destructorDelegate = (DestructorDelegate) complexDeleter;\r\n\r\n    forAll(iterator, 100) {\r\n        // create struct and add to array\r\n        ComplexStruct *some = malloc(sizeof(ComplexStruct));\r\n        some->id = iterator + 1;\r\n        some->fullName = stringWithFormat(\"Object # %lu\", iterator + 1); // more string processing API in RString.h\r\n        $(array, m(addObject, RArray)), some);\r\n    }\r\n    // print\r\n    printerOfRArray(array);\r\n\r\n    // delete, automatically calls destructor delegate and free array prt\r\n    deleter(array, RArray);\r\n\r\n    // some syntaxic sugar see initFromArray, initFromArrayWithSizes, arrayFromArray\r\n\r\n    // create array of strings\r\n    RString *uniqTok = RS(\"Unique token\");\r\n    array = RA(RS(\"Token 1\"), RS(\"Token 2\"), uniqTok, nil); // must be NULL terminated\r\n\r\n    array->printerDelegate = (PrinterDelegate) p(RString);\r\n    array->destructorDelegate = free;\r\n\r\n    printerOfRArray(array);\r\n\r\n    RCompareDelegate delegate;\r\n    delegate.etaloneObject = uniqTok;\r\n    delegate.virtualCompareMethod = (RCompareFlags (*)(pointer, pointer)) compareWithRString;\r\n\r\n    RFindResult result = findObjectWithDelegateRArray(array, &delegate); // search\r\n\r\n    if(result.object != nil) { // object != nil -> found object, place also logged\r\n        printf(\"Found some object at place %lu!\\n\", result.index);\r\n    } else {\r\n        printf(\"Object not found!\\n\");\r\n    }\r\n\r\n    RArray *subarray = getSubarrayRArray(array, makeRRange(1, 2)); // delegates will be copied\r\n    printerOfRArray(subarray);\r\n    subarray->destructorDelegate = nil; // not want to delete strings\r\n    deleter(subarray, RArray);\r\n\r\n    deleter(array, RArray); // cleanup strings\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\nRDictionary use:  \r\n\r\n```C\r\n#include <RayFoundation.h>\r\n#include \"Tests.h\"\r\n\r\nint main(int argc, const char *argv[]) {\r\n    enablePool(RPool);\r\n    ComplexTest();\r\n\r\n    RDictionary *dict =  dictionaryFromPairs(\"key\", \"value\",\r\n                                             \"key2\", \"value2\",\r\n                                             \"key3\", \"value3\",\r\n                                             \"key4\", \"value4\",\r\n                                             \"key5\", \"value5\",\r\n                                             nil);\r\n\r\n    char * string = $(dict, m(getObjectForKey, RDictionary)), \"key4\");\r\n\r\n    printf(\"Found object for \\'key4\\' - \\'%s\\' \\n\\n\", string);\r\n\r\n    deleter(dict, RDictionary);\r\n\r\n    endRay(); // standart cleanup\r\n}\r\n```\r\n\r\nBrainFuck samples:\r\n\r\n```C\r\n#include \"RayFoundation/RayFoundation.h\"\r\n#include \"RVirtualMachine/RVirtualFunction/RVirtualFunction.h\"\r\n#include \"RVirtualMachine/RVirtualMachine/RVirtualMachine.h\"\r\n#include \"RVirtualMachine/RVirtualCompiler.h\"\r\n\r\nint main(int argc, const char *argv[]) {\r\n    // ezy brainfuck hello world\r\n    RVirtualFunction *function = $(RVC, m(createFunctionFromBrainFuckSourceCode, RVirtualCompiler)),\r\n            RS(\" My brainfuck hello world : +++++++++++++++++++++++++++++++++++++++++++++\\n\"\r\n                    \" +++++++++++++++++++++++++++.+++++++++++++++++\\n\"\r\n                    \" ++++++++++++.+++++++..+++.-------------------\\n\"\r\n                    \" ---------------------------------------------\\n\"\r\n                    \" ---------------.+++++++++++++++++++++++++++++\\n\"\r\n                    \" ++++++++++++++++++++++++++.++++++++++++++++++\\n\"\r\n                    \" ++++++.+++.------.--------.------------------\\n\"\r\n                    \" ---------------------------------------------\\n\"\r\n                    \" ----.-----------------------.\"));\r\n\r\n    // execute of byte-code on RVM singleton\r\n    executeRay(function);\r\n    $(function, d(RVirtualFunction)) );\r\n\r\n    // brainfuck compiler multiple-cycles test\r\n    function = $(RVC, m(createFunctionFromBrainFuckSourceCode, RVirtualCompiler)),\r\n            RS(\" Cycles : +++ [ > +++ [.-] <-]\")); // prints '03 02 01' 3-times\r\n    executeRay(function);\r\n    $(function, d(RVirtualFunction)) );\r\n\r\n    // brainfuck hard(with [, ]) hello world on RVM\r\n    function = $(RVC, m(createFunctionFromBrainFuckSourceCode, RVirtualCompiler)),\r\n            RS(\" Hard Hello world : ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++\\n\"\r\n                                  \" .>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.\\n\"\r\n                                  \" ------.--------.>+.>.\"));\r\n\r\n    // rasm byte-code print in words\r\n    $(function, p(RVirtualFunction)) );\r\n\r\n    executeRay(function);\r\n    $(function, d(RVirtualFunction)) );\r\n    \r\n    // final function delete\r\n    deallocator(function);\r\n\r\n    // RVM singleton cleanup\r\n    deleteRVM();\r\n    endRay(); // standart cleanup\r\n}\r\n```\r\nRAutoPool:  \r\n\r\n```C\r\nint main(int argc, const char *argv[]) {\r\n    initPointers();\r\n    enablePool(RPool); // enable pool sinleton\r\n    ComplexTest();     // do something \r\n\r\n    $(RPool, p(RAutoPool)));   // check leaks\r\n    deleter(RPool, RAutoPool); // total cleanup \r\n    return 0;\r\n    // or use macro endRay -> standart cleanup\r\n}\r\n```\r\n\r\nWork with RClassTable:\r\n\r\n```C\r\n#include \"RayFoundation/RClassTable/RClassTable.h\"\r\n\r\nvoid RClassTableTest(void){\r\n\r\n    // register class name once, and get identifier in result\r\n    // it's can be used like management tool for creating unique \r\n    // identifiers for string objects (in our case class names)\r\n    \r\n    registerClassOnce(\"Luke\");\r\n    // print our class table\r\n    printRCTS;\r\n\r\n    registerClassOnce(\"Dart\");\r\n    printRCTS;\r\n\r\n    registerClassOnce(\"Leia\");\r\n    printRCTS;\r\n    \r\n    // try once more, but here is only one record\r\n    registerClassOnce(\"Leia\");\r\n    registerClassOnce(\"Dart\");\r\n    registerClassOnce(\"Luke\");\r\n    registerClassOnce(\"Han Solo\");\r\n    printRCTS;\r\n    // get Identifier of Han Solo\r\n    char *checkName = \"Han Solo\";\r\n    RPrintf(\"Identifier of %s is - %qu \\n\", checkName, registerClassOnce(checkName));\r\n    \r\n    // flush your class table\r\n    flushRCTS;\r\n    printRCTS;\r\n    \r\n    // delete your class table\r\n    releaseRCTS;\r\n    \r\n    // use not singleton\r\n    RClassTable *table = makeRCTable();\r\n\r\n    $(table, m(registerClassWithName, RClassTable)), \"Some string\");\r\n    $(table, m(registerClassWithName, RClassTable)), \"Some string2\");\r\n    $(table, m(registerClassWithName, RClassTable)), \"Some string3\");\r\n    // once more time, to check\r\n    $(table, m(registerClassWithName, RClassTable)), \"Some string3\");\r\n\r\n    $(table, p(RClassTable)) );\r\n\r\n    $(table, d(RClassTable)) );\r\n    deallocator(table);\r\n}\r\n```\r\n\r\nYou can simply use it in Yours C++ projects:\r\n\r\n```C++\r\n#include <iostream>\r\n\r\n#include \"RayFoundation.h\"\r\n\r\nusing namespace std;\r\n\r\nclass MyClass{\r\nprotected:\r\n    double x;\r\n    double y;\r\npublic:\r\n    MyClass(){\r\n\r\n    }\r\n    ~MyClass(){\r\n\r\n    }\r\n    void Print(){\r\n        cout << \"MyClass obj - \" << this << endl;\r\n    }\r\n};\r\n\r\nvoid deleter(pointer src) {\r\n    delete (MyClass*)src;\r\n}\r\n\r\nvoid Printer(pointer src){\r\n    ((MyClass*)src)->Print();\r\n}\r\n\r\nint main(int argc, const char *argv[]) {\r\n\r\n    RArray *helloArray = makeRArray();\r\n\r\n    helloArray->destructorDelegate = deleter;\r\n    helloArray->printerDelegate = Printer;\r\n\r\n    for(unsigned i = 0; i < 100000; ++i) {\r\n        MyClass *a = new MyClass;\r\n        addObjectRArray(helloArray, a);\r\n    }\r\n\r\n    $(helloArray, p(RArray)));\r\n    deleteRA(helloArray);\r\n    return 0;\r\n}\r\n```\r\nSome multi-thread tcp-echo server sample on RTCPHandler:  \r\n\r\n```C\r\n#include <RayFoundation/RayFoundation.h>\r\n\r\n#include \"Tests.h\"\r\n\r\n#define BUFFER_SIZE 1500\r\n\r\npointer exec(RTCPDataStruct *data) {\r\n    char    buffer[BUFFER_SIZE];\r\n    const char    *address = addressToString(&data->socket->address);\r\n    ushort            port = ntohs(data->socket->address.sin_port);\r\n    unsigned currentThread =  (unsigned int) currentThreadIdentifier();\r\n    byte     resultFlag;\r\n    size_t   receivedSize;\r\n\r\n    RPrintf(\"[I] %s:%u connected [tuid : %u]\\n\", address, port, currentThread);\r\n\r\n    $(data->socket, m(sendString, RSocket)), RS(\"Hello from RServer.\\n\"));\r\n\r\n    resultFlag = $(data->socket, m(receive, RSocket)), buffer, 1000, &receivedSize);\r\n    while(resultFlag != networkConnectionClosedConst) {\r\n        buffer[receivedSize] = 0;\r\n        RPrintf(\"%s:%u[%u] > %s\", address, port, currentThread, buffer);\r\n        $(data->socket, m(send, RSocket)), buffer, receivedSize);\r\n        resultFlag =  $(data->socket, m(receive, RSocket)), buffer, BUFFER_SIZE, &receivedSize);\r\n    }\r\n\r\n    RPrintf(\"[I] %s:%u disconnected [tuid : %u]\\n\", address, port, currentThread);\r\n\r\n    deleter(data->socket, RSocket);\r\n    data->socket = nil; // for auto-cleaning\r\n    return nil;\r\n}\r\n\r\nRTCPHandler  *server   = nil;\r\nRTCPDelegate *delegate = nil;\r\n\r\nvoid startServer(void) {\r\n    server = c(RTCPHandler)(nil);\r\n    if(server != nil) {\r\n        delegate = allocator(delegate);\r\n        if(delegate != nil) {\r\n            delegate->delegateFunction = (RThreadFunction) exec;\r\n            delegate->context          = server;\r\n            $(server,  m(set_delegate, RTCPHandler)), delegate);\r\n            RPrintf(\"RTCPHandler starting %p\\n\", server);\r\n            $(server,  m(startOnPort, RTCPHandler)), 4000);\r\n        }\r\n    }\r\n}\r\n\r\nint main(int argc, const char *argv[]) {\r\n    rbool closeAll = no;\r\n    byte connectionState;\r\n    char buffer[BUFFER_SIZE];\r\n    const char *address;\r\n    ushort port;\r\n    RSocket *configurator;\r\n    size_t  receivedSize;\r\n\r\n    enablePool(RPool);\r\n    ComplexTest(); // lib test\r\n\r\n    startServer();\r\n\r\n    configurator = openListenerOnPort(4001, 10);\r\n    if(configurator == nil) goto exit;\r\n\r\n    while(!closeAll) {\r\n        RSocket *current = $(configurator, m(accept, RSocket)));\r\n\r\n        address = addressToString(&current->address);\r\n        port    = ntohs(current->address.sin_port);\r\n\r\n        RPrintf(\"[I] Configurator %s:%u connected\\n\", address, port);\r\n        connectionState = networkOperationSuccessConst;\r\n\r\n        while(connectionState != networkConnectionClosedConst) {\r\n            connectionState = $(current, m(receive, RSocket)), buffer, BUFFER_SIZE, &receivedSize);\r\n            if(connectionState == networkOperationSuccessConst) {\r\n                if(receivedSize > 8) {\r\n                    buffer[receivedSize] = 0;\r\n                    ifMemEqual(buffer, \"secretkey\", 9) {\r\n\r\n                        ifMemEqual(buffer + 10, \"shutdown\", 8) {\r\n                            $(current, m(sendString, RSocket)), RS(\"Server will terminate\\n\"));\r\n                            RPrintf(\"[I] Will terminate with command from %s:%u\\n\\n\", address, port);\r\n\r\n                            closeAll = yes;\r\n                        }\r\n\r\n                        ifMemEqual(buffer + 10, \"system\", 6) {\r\n                            RPrintf(\">> Execute %s\", buffer + 17);\r\n                            system(buffer + 17);\r\n                        }\r\n\r\n                    } else {\r\n                        RPrintf(\"[E] Bad user key on %s:%u\\n\", address, port);\r\n                    }\r\n                }\r\n                connectionState = networkConnectionClosedConst;\r\n            } else if (connectionState == networkOperationErrorConst) {\r\n                RError2(\"[E] Receive on configurator connection, from %s:%u\", current, address, port);\r\n            }\r\n        }\r\n\r\n        deleter(current, RSocket);\r\n    }\r\n\r\n    deleter(configurator, RSocket);\r\n\r\n    deallocator(delegate);\r\n    p(RTCPHandler)(server);\r\n    $(server, m(terminate, RTCPHandler)));\r\n    deleter(server,        RTCPHandler);\r\n\r\n    exit:\r\n    endSockets();\r\n    endRay();\r\n}\r\n```\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}